[
  {
    "objectID": "Homework6.html",
    "href": "Homework6.html",
    "title": "Homework 6 - Savannah Harrison",
    "section": "",
    "text": "Homework 6 - Savannah Harrison\n\n\nTask 1: Conceptual Questions\n\nWhat is the purpose of the lapply() function? What is the equivalent purrr function?\nThe lapply() function is used to apply a function to all elements of a list and it returns a list object of the same length. The equivalent purrr function is purrr::map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below! (I’m really trying to ask you how you specify method = “kendall” when calling lapply())\n\nlapply(my_list, function(df) cor(df, method = “kendall”))\n\nWhat are two advantages of using purrr functions instead of the BaseR apply family? Using the purrr functions allows for greater consistency between functions and they have lots of helper functions that are useful.\nWhat is a side-effect function? A side-effect function (ex: print(), write_csv()) doesn’t change the data, it just tries to produce something.\nWhy can you name a variable sd in a function and not cause any issues with the sd function? When a function is called, there is a temperary function environment. Variables inside of functions do not exist outside of the function, which is why if you name a variable sd it will not translate outside of the function. It will go back to its built-in meaning.\n\n\n\nTask 2: Writing R Functions\nWriting RMSE function.\n\ngetRMSE &lt;- function(responses, predictions, ...) {\n  if (length(responses) != length(predictions)) {\n    stop(\"Responses and predictions must have same length.\")\n  }\n  squared_diffs &lt;- (responses-predictions)^2\n  \n  mean_squared_error &lt;- mean(squared_diffs, ...)\n  \n  RMSE &lt;- sqrt(mean_squared_error)\n  \n  return(RMSE)\n  }\n\nCreating response values and predictions to test.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTesting RMSE function with created data.\n\nRMSE1 &lt;- getRMSE(resp, pred)\nprint(RMSE1)\n\n[1] 0.9581677\n\n\nReplacing two response values with NA.\n\nresp_with_na &lt;- resp\nresp_with_na[1] &lt;- NA_real_\nresp_with_na[2] &lt;- NA_real_\n\nTesting without specifting behavior for NA.\n\nRSME2 &lt;- getRMSE(resp_with_na, pred)\nprint(RSME2)\n\n[1] NA\n\n\nTesting with specifting behavior for NA.\n\nRSME3 &lt;- getRMSE(resp_with_na, pred, na.rm = TRUE)\nprint(RSME3)\n\n[1] 0.9661699\n\n\nCreating MAE function.\n\ngetMAE &lt;- function(responses, predictions, ...) {\n   if (length(responses) != length(predictions)) {\n    stop(\"Responses and predictions must have same length.\")\n  }\n  diffs &lt;- abs(responses-predictions)\n  \n  MAE &lt;- mean(diffs,...)\n  \n  return(MAE)\n}\n\nCreating response values and predictions to test MAE function.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp2 &lt;- 3 + 10 * x + rnorm(n)\npred2 &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTesting MAE function using the data.\n\nMAE1 &lt;- getMAE(resp2, pred2)\nprint(MAE1)\n\n[1] 0.8155776\n\n\nReplacing two response values with missing values.\n\nresp_with_na2 &lt;- resp2\nresp_with_na2[1] &lt;- NA_real_\nresp_with_na2[2] &lt;- NA_real_\n\nTesting without specifting behavior for NA.\n\nMAE2 &lt;- getMAE(resp_with_na2, pred2)\nprint(MAE2)\n\n[1] NA\n\n\nTesting with specifting behavior for NA.\n\nMAE3 &lt;- getMAE(resp_with_na2, pred2, na.rm = TRUE)\nprint(MAE3)\n\n[1] 0.8241201\n\n\nCreating metrics wrapper function to get either or both metrics.\n\ngetMetrics &lt;- function(responses, predictions, metrics = c(\"RMSE\", \"MAE\"),...) {\n  if(!is.vector(responses) || !is.vector(predictions) ||\n     !is.atomic(responses) || !is.atomic(predictions) ||\n     !is.numeric(responses) || !is.numeric(predictions)) {\n       stop(\"Responses and predictions must be numeric atomic vectors.\")\n     }\n     \nresults &lt;- list()\n     \n  if(\"RMSE\" %in% metrics) {\n    results$RMSE &lt;- getRMSE(responses, predictions, ...)\n  }\n  if(\"MAE\" %in% metrics) {\n    results$MAE &lt;- getMAE(responses, predictions, ...)\n  }\n\nreturn(results)\n}\n\nCreating response values and predictions to test.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp3 &lt;- 3 + 10 * x + rnorm(n)\npred3 &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTesting the function with “RMSE”.\n\nMetrics1 &lt;- getMetrics(resp3, pred3, \"RMSE\")\nprint(Metrics1)\n\n$RMSE\n[1] 0.9581677\n\n\nTesting the function with “MAE”.\n\nMetrics2 &lt;- getMetrics(resp3, pred3, \"MAE\")\nprint(Metrics2)\n\n$MAE\n[1] 0.8155776\n\n\nSpecifying both metrics.\n\nMetrics3 &lt;- getMetrics(resp3, pred3, )\nprint(Metrics3)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\nReplacing two repsonse values with missing values.\n\nresp_with_na3 &lt;- resp3\nresp_with_na3[1] &lt;- NA_real_\nresp_with_na3[2] &lt;- NA_real_\n\nTesting the function with the missing values.\n\nMetrics4 &lt;- getMetrics(resp_with_na3, pred3, \"RMSE\")\nprint(Metrics4)\n\n$RMSE\n[1] NA\n\n\n\nMetrics5 &lt;- getMetrics(resp_with_na3, pred3, \"RMSE\", na.rm = TRUE)\nprint(Metrics5)\n\n$RMSE\n[1] 0.9661699\n\n\n\nMetrics6 &lt;- getMetrics(resp_with_na3, pred3, \"MAE\")\nprint(Metrics6)\n\n$MAE\n[1] NA\n\n\n\nMetrics7 &lt;- getMetrics(resp_with_na3, pred3, \"MAE\", na.rm = TRUE)\nprint(Metrics7)\n\n$MAE\n[1] 0.8241201\n\n\n\nMetrics8 &lt;- getMetrics(resp_with_na3, pred3,)\nprint(Metrics8)\n\n$RMSE\n[1] NA\n\n$MAE\n[1] NA\n\n\n\nMetrics9 &lt;- getMetrics(resp_with_na3, pred3, na.rm = TRUE)\nprint(Metrics9)\n\n$RMSE\n[1] 0.9661699\n\n$MAE\n[1] 0.8241201\n\n\nTesting the function by passing in incorrect data.\n\n#Metrics5 &lt;- getMetrics(iris)\n\n\n\nTask 3: Querying an API and a Tidy-Style Function\n\nlibrary(httr)\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(purrr)\nlibrary(jsonlite)\n\n\nAttaching package: 'jsonlite'\n\n\nThe following object is masked from 'package:purrr':\n\n    flatten\n\n\n\nteslaurl &lt;- \"https://newsapi.org/v2/everything?q=tesla&from=2024-09-15&sortBy=publishedAt&apiKey=c36df82613354f00b6331308d41865d6\"\nteslareturn &lt;- httr::GET(teslaurl)\nparsedtesla &lt;- fromJSON(rawToChar(teslareturn$content))\nteslastats &lt;- as_tibble(parsedtesla)\narticles &lt;- pluck(parsedtesla$articles$content)\n\n\narticles\n\nNULL\n\n\n\ngetNews &lt;- function(subject, time_period, API_key) {\n  url &lt;- \"https://newsapi.org/v2/everything\"\n  response &lt;- httr::GET(url, query = list( \n    q = subject,\n    from = time_period,\n    apiKey = API_key))\n  \n   if (status_code(response) == 200) {\n     news_data &lt;- content(response, as = \"parsed\", type = \"application/json\")\n     \n    articles &lt;- news_data$articles\n    articles_df &lt;- as.data.frame(articles)\n     return(articles_df)\n  } else {\n    return(paste(\"Error:\", status_code(response)))\n  }\n}\n\n\nAPI_key &lt;- \"c36df82613354f00b6331308d41865d\"\n\n\nresult &lt;- getNews(\"Tesla\", \"2024-09-15\", API_key)"
  }
]